#并发
并行的执行程序的多个部分就是并发，并行编程使得程序执行速度得到极大的提高。创建新执行线程有两种方法：

- 一种方法是将类声明为 `Thread` 的子类；
- 一种方法是声明实现 `Runnable` 接口的类。该类然后实现 `run` 方法。然后可以分配该类的实例，在创建 `Thread` 时作为一个参数来传递并启动

例子：

```java

    public class Demo
    {
    	public static void main(String[] args){
    		new MyThread(5).start();//third output
    		new Thread(new MyRun()).start();//second output
    		System.out.println("before or after");//first output
    	}
    }
    class MyRun implements Runnable//实现接口
    {
    	private static int count=0;
    	private final int id=count++;
    	private int taskCount=10;
    	public String status(){
    		return "#"+id+"("+taskCount+"),";
    	}
    	public void run(){
    		while(taskCount-->0){
    			System.out.print(status());
    		}
    		System.out.println();
    	}
    }
    class MyThread extends Thread//继承线程
    {
    	private int times=10;
    	MyThread(int t){times=t;};
    	public void run(){
    		for(int i=0;i<times;i++){			
    			try{
    				sleep(10);//休眠10ms
    			}catch(InterruptedException e){//睡眠线程是否被中断，中断抛出异常
    				e.printStackTrace();
    			}
    			System.out.print(i+": zhouchaoyuan ");
    		}
    	}
    }

```

当线程较多的时候，我们可以使用线程池来管理线程。如使用
`Executors.newCachedThreadPool()`返回一个`ExecutorService`来执行`Runnable`对象,如下面的例子：

```java

    import java.util.concurrent.*;
    public class Demo
    {
    	public static void main(String[] args){
    		ExecutorService exe=Executors.newCachedThreadPool();//返回值向上转型
			System.out.println(exe.getClass());
    		for(int i=0;i<5;i++){//MyRun()是上面例子的类
    			exe.execute(new MyRun());//execute是从Executor继承的方法
    		}
    		exe.shutdown();//顺序关闭,防止新任务提交给exe
    	}
    }

```

对于`Runnable`的`run`并没有返回值，如果我们想要返回值，那么我们可以实现接口`Callable<V>`，其中V是返回参数类型。然后将其`submit`给一个`ThreadPoolExecutor`执行并返回`Future`，使用`get`取得结果。

**优先级和让步和后台线程**

- 每一个线程都有一个优先级，调度器一般调度优先级较高的线程。
- 慎用yield，调用此静态方法时，一般时暗示当前线程可以让步cpu给其他相同级别的线程调用了，不过这个仅仅只是一个建议。
- 后台线程是在后台提供服务的线程，所有非后台进程结束了程序也就结束了，同时会杀死所有后台线程（**就算有finally语句也不会被执行**），并且由后台线程创建的线程也是后台线程。

关于`join`和`interrupt`，在当前线程`u`中使用另一个线程t调用`t.join()`,那么当`u`将被挂起，直到`t`结束`u`才恢复。而`interrupt`是中断当前线程。

###捕获异常
由于异常的本质特性，使得你不能捕获从线程中逃逸的异常。

```java

    import java.util.concurrent.*;
    public class MyThread implements Runnable
    {
    	public void run(){
    		throw new RuntimeException();
    	}
    	public static void main(String[] args){
    		try{//即使使用try{}catch(){}也无法捕获异常
    			ExecutorService exe=Executors.newCachedThreadPool();
    			exe.execute(new MyThread());
    		}catch(Exception e){}
    	}
    }/*output:
	Exception in thread "pool-1-thread-1" java.lang.RuntimeException
        	at MyThread.run(MyThread.java:5)
        	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
        	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
        	at java.lang.Thread.run(Unknown Source)
	*/

```

解决这个问题是使用接口`Thread.UncaughtExceptionHandler`,将其附着在一个线程上面，就可以捕获异常了，例子如下：

```java

    import java.util.concurrent.*;
    public class MyThread implements Runnable
    {
    	public void run(){
    		throw new RuntimeException();
    	}
    	public static void main(String[] args){//传递一个工厂参数，
    		ExecutorService exe=Executors.newCachedThreadPool(new MyUncaughtFactory());
    		exe.execute(new MyThread());
    	}
    }
    class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler
    {//捕获到异常调用此方法
    	public void uncaughtException(Thread t,Throwable e){
    		System.out.println("caught "+e);
    	}
    }
    class MyUncaughtFactory implements ThreadFactory
    {
    	public Thread newThread(Runnable r){
    		Thread t=new Thread(r);
    		//设置异常捕获
    		t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
    		return t;
       }
    }

```

除此之外我们还可以使用`Thread.setDefaultUncaughtExceptionHandler(...)`来设置默认的的异常捕获处理器。