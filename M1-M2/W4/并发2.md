#并发
###共享资源
在多线程的环境下面，我们很容易就不正确的访问了资源，以下是一个例子：

```java

	import java.util.concurrent.*;
	public class Demo
	{
		public static void main(String[] args){
			Data data=new Data();
        	for(int i=0;i<100;i++){
	            new Thread(new MyRun(data)).start();
        	}
			try{
				TimeUnit.SECONDS.sleep(2);//尝试等待所有线程结束然后再输出结果
			}catch(InterruptedException e){}
			System.out.println(data.getCount());//预期输出10000，但事实上不是
		}
	}
	class MyRun implements Runnable//实现接口
	{
		public Data data;
		MyRun(Data data){this.data=data;}
		public void run(){
    		for(int i=0;i<100;i++){
    			data.upCount();
    		}
    	}
    }
    class Data
    {
    	private int count=0;
    	public void upCount(){
			int t=count+1;
			Thread.yield();
			count=t;
		}
    	public int getCount(){return count;}
    }

```

上面的代码开启了100个线程每个对`data`的字段`count`增100次1，结果却是不是每次都像预料的那样，说明在一个线程还没有来得急给`count`加一，另一个线程又获取了当前的`count`值，导致结果的不确定。

一个解决的方法就是给`upCount`加锁，也就是在给方法加`synchronized`修饰。对于一个对象来说，所有的被sunchronized修饰的方法共享一个锁，锁被一个任务获得其他的任务就不能获得这个锁，而且同一个任务可以多次获得这个锁（还可以使用`java.util.concurrent.locks`显示加锁），如：

```java

	synchronized public void upCount(){
		int t=count+1;
		Thread.yield();
		count=t;
	}

```

**原子操作：**不能被线程调度机制中断的操作

对于volatile有时常常会误用，我们一般遵循**Brian同步规则:**

**如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。**

###临界区
有时候我们只希望对一部分代码段进行加锁而不是一个整个方法，这一部分被加锁的代码我们称为临界区（同步控制块），使用这种方法一般比修饰一整个方法的速度快，他的`synchronized`形式如下：

	synchronized(syncObject){
		//同一时间只能有一个线程访问这个代码段
	}
上述的对象`syncObject`的锁一旦被获取，那么这个对象的`synchronized`方法和临界区都将被上锁。

显式加锁形式：

```java

	Lock lock=new ReentrantLock();
	lock.lock();
	try{
		//同一时间只能有一个线程访问这个代码段
	}
	finally{
		lock.unlock();
	}

```

共享变量总是产生冲突，有时候我们会使用相同的变量`ThreadLocal`来给每个线程创建不同的存储，
###终结任务
一般是在任务运行过程中中断任务，而不是达到某一检查点终结任务，他很类似抛出异常。一般在读取I/O(nio被关闭时可以中断)或者在`synchronized`上的等待我们是无法中断任务，而在可以抛出`InterruptedException`异常的操作是可以被终端，如下是一个例子：

```java

    import java.io.*;
    import java.util.concurrent.*;
    public class Demo
    {
    	static ExecutorService exe=Executors.newCachedThreadPool();
    	public static void test(Runnable r)throws InterruptedException{
    		Future<?> f=exe.submit(r);
    		TimeUnit.MILLISECONDS.sleep(100);
    		System.out.println("Interrupting "+r.getClass().getName());
    		f.cancel(true);//如果f对应的线程在运行那么尝试中断线程
    		System.out.println("Interrumpt sent to "+r.getClass().getName());
    	}
    	public static void main(String[] args)throws InterruptedException{
    		test(new Normal());
    		test(new AboutIO());
    		test(new AboutSynchronized());
    		TimeUnit.SECONDS.sleep(2);
    		System.exit(0);
    	}
    }
    class Normal implements Runnable
    {
    	public void run(){
    		try{
    			TimeUnit.MILLISECONDS.sleep(500);
    		}catch(InterruptedException e){//中断输出
    			System.out.println("Interrupt from Normal");
    		}
    	}
    }
    class AboutIO implements Runnable
    {
    	public void run(){
    		try{
    			System.in.read();
    		}catch(Exception e){//中断输出
    			System.out.println("Interrupt from AboutIO");
    		}
    	}
    }
    class AboutSynchronized implements Runnable
    {
    	synchronized void f(){
    		while(true)Thread.yield();
    	}
    	AboutSynchronized(){
    		new Thread(){
    			public void run(){
    				f();
    			}
    		}.start();
    	}
    	public void run(){
    		f();//中断输出
    		System.out.println("Exiting from AboutSynchronized.run()");
    	}
    }

```

输出：

    Interrupting Normal
    Interrupt from Normal
    Interrumpt sent to Normal
    Interrupting AboutIO
    Interrumpt sent to AboutIO
    Interrupting AboutSynchronized
    Interrumpt sent to AboutSynchronized
另外在ReentrantLock上的阻塞具备被中断的能力，另外中断之后捕获异常就清除了中断标记。