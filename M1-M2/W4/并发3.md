#并发
###协调线程
多个线程可以协调工作，加快进程，一般他们之间有一定的依赖关系。有时候通过`wait()`和`notifyAll()`可以很好的协调他们之间的工作，这两个方法一般都要在`synchronized`方法中调用调用，以下是一个例子：

```java

    import java.io.*;
    import java.util.concurrent.*;
    public class Demo
    {
    	public static void main(String[] args)throws InterruptedException{
    		ExecutorService exe=Executors.newCachedThreadPool();
    		Switch swi=new Switch();
    		exe.execute(new SwitchOff(swi));
    		exe.execute(new SwitchOn(swi));
    		TimeUnit.SECONDS.sleep(2);
    		exe.shutdownNow();
    	}
    }
    class Switch
    {
    	private boolean _on=false;
    	public synchronized void on(){
    		_on=true;
    		notify();//唤醒在此对象监视器上等待的单个线程
    	}
    	public synchronized void off(){
    		_on=false;
    		notifyAll();//要在synchronized方法中调用
    	}
    	public synchronized void waitForOn()throws InterruptedException{
    		if(!_on)wait();//挂起线程，等待合适的条件再执行，挂起时释放锁
    	}
    	public synchronized void waitForOff()throws InterruptedException{
    		while(_on)wait();//使用while比上面使用if更安全，当多个线程被环唤醒时可以适应
    	}
    }
    class SwitchOn implements Runnable
    {
    	private Switch swi;
    	SwitchOn(Switch swi){this.swi=swi;}
    	public void run(){
    		try{	
    			while(!Thread.interrupted()){
    				swi.on();			
    				TimeUnit.MILLISECONDS.sleep(100);
    				swi.waitForOff();//等待关闭执行完毕就是关闭的
    				System.out.println("开关是关闭的，等待打开");
    			}
    		}catch(InterruptedException e){//捕获异常，中断标记被清除
    			System.out.println("interupted from SwitchOn");
    		}
    		System.out.println("The end of SwitchOn");
    	}
    }
    class SwitchOff implements Runnable
    {
    	private Switch swi;
    	SwitchOff(Switch swi){this.swi=swi;}
    	public void run(){
    		try{
    			while(!Thread.interrupted()){
    				swi.waitForOn();//等待打开执行完毕就是打开的
    				System.out.println("开关是打开的，等待关闭");
    				TimeUnit.MILLISECONDS.sleep(100);
    				swi.off();
    			}
    		}catch(InterruptedException e){//捕获异常，中断标记被清除
    			System.out.println("interupted from SwitchOff");
    		}			
    		System.out.println("The end of SwitchOff");
    	}
    }

```

上述代码开关交替打开和关闭，说明两个线程相互循环依赖和协作。上面的代码也可以通过显式的锁`Lock`和`Condition`来实现，其中调用`await()`和`signal()`。

一般情况（如生产者消费者问题）我们实现线程之间的通信通常用实现了`java.util.concurrent.BlockingQueue()`的队列来自动同步,如：`LinkedBlockingQueue`,`ArrayBlockingQueue`,`SynchronoutQueue`，使用它们将非常方便。

在线程之间协调合作的时候，有可能会产生**死锁**（任务之间互相等待又持续得不到资源的情况称为死锁），如著名的哲学家就餐问题，死锁有四个条件，我们通过破除一个条件来避免死锁。如对于哲学家问题我们通过最后一个哲学家的行为策略不同（其他的为先右后左，他为先左后右）来避免死锁。