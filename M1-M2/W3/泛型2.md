#泛型
####通配符
一个关于数组的例子：

	class Building{}
	class House extends Building{}
	class Hotel extends Building{}
	public class Demo{
		public static void main(String[] args){
			Building[] b=new House[10];
			try{
				//java.lang.ArrayStoreException
				b[0]=new Hotel();
				//b[0]=new Building();抛出同样的异常，只能是House或者其子类
			}catch(Exception e){
				System.out.println(e);
				//output: java.lang.ArrayStoreException: Hotel
			}
		}
	}
编译通过，运行抛出异常。上面的b数组实际上运行时类型是House[]的，它处理的是House[]，因此向数组中放置异构类型（或者父类型）就会抛出异常。
	
**有边界的泛型：**<? extends T>(协变参数）边界是T，表示持有T的任何子类。使用了这个之后不能添加元素，原因是对于<? extends Number>可能本来持有的是Integer，但是尝试添加Double是不允许的，所以禁止了add。而get是可以的，因为他至少是一个T类型（上面的例子是返回Number），如下：

	import java.util.*;
	public class Demo{
		public static void main(String[] args){
			//! List<Number> list=new ArrayList<Integer>();编译不通过持有类型不一样
			List<? extends Number> list=new ArrayList<Integer>();
			//它并不知道确切的类型，只持有的是Number的任何子类，我们不能添加任何具体类型到list，除了null
			//!  list.add(new Integer(2));  //错误的
			list.add(null);
		}
	}
**超类型通配符**：<? super T>(逆变参数）表示持有的类型至少是T以及T的父类，因此我们对于T以及T的子类都是可以添加的，因为持有的类型的下界是T，这样的话add(T or T的子类)都可以向上转型，不过这个时候使用get的时候我们就不知道持有类型具体是哪一个了，因为有可能是T以及T父类其中的一个，因此我们只能返回一个Object，不能返回一个T。（p393-p394）：
	
	import java.util.*;
	class Building{}
	class House extends Building{}
	class Hotel extends Building{}
	public class Demo{
		static List<House> house=new ArrayList<House>();
		static List<Building> building=new ArrayList<Building>();
		static <T> void write(List<T>list,T item){//使用一个确切的类型（没有通配符）
			list.add(item);//没有通配符，可以添加
		}
		static void f1(){
			write(house,new House());
			//! write(building,new House());  error
			building.add(new House());//can add
		}	
		static <T> void writeWithSuper(List<? super T>list,T item){
			list.add(item);
		}
		static void f2(){
			writeWithSuper(house,new House());
			writeWithSuper(building,new House());//can add
		}
    	public static void main(String[] args){
			f1();f2();
	    }
	}

**无界通配符**：<?>看起来很想着“任何事物”，但是<?>实际上声明的是“我想用java泛型来编写这段代码，但是我现在还不知道具体的泛型是什么，他可以持有任何类型”，显然这里我们不能使用add，因为很简单会add一个异构类，但是get却是可是使用的，用一个Object接收get返回的值即可：

	import java.util.*;
	public class Demo{
		static void work(List<?>list){
			//! list.add(new Integer(2)); //error
			//! list.add(new Double(3)); //error
			list.add(null);//ok
			Object obj=list.get(0);
		}
		public static void main(String[] args){
			work(new ArrayList<Integer>(Arrays.asList(1)));
			work(new ArrayList<Double>(Arrays.asList(1.3)));
		}
	}

**无界通配符的捕获转换**：向<?>传递一个原生类型，编译器有可能推断出这个类型，如下：

	import java.util.*;
	public class Demo{
		static <T> void f1(List<T>list){
			System.out.println(((T)list.get(0)).getClass().getSimpleName());
		}
		static <T> void f2(List<?>list){
			f1(list);
		}
		@SuppressWarnings("unchecked")
		public static void main(String[] args){
			List list=new ArrayList<Integer>(Arrays.asList(1));
			f2(list);
		}
	}
	/**ouput:
	Integer
	*/

####自限定类型
基本的使用如下：

	class SelfBounded<T extends SelfBounded<T>>{}
	//上面的形式就限定了参数必须是SelfBounded的子类如：
	class A extends SelfBounded<A>{}
	class B extends SelfBounded<A>{}
	class C{}
	//下面的形式是不行的，因为C不是SelfBounded的子类
	//! class D extends SelfBounded<C>{}
	//原生类型是可行的
	class E extends A{}
自限定类型更可以用来产生协变参数类型(只接受子类参数但是可以返回基类类型)，如：

	inteface A<T extends A<T>>{
		T get();
	}
	inteface B extends A<B>{}
	public class Demo{
		void test(B b){
			B bb=b.get();
			A aa=b.get();//协变
		}
	}