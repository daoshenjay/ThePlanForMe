#泛型
####通配符
一个关于数组的例子：

	class Building{}
	class House extends Building{}
	class Hotel extends Building{}
	public class Demo{
		public static void main(String[] args){
			Building[] b=new House[10];
			try{
				//java.lang.ArrayStoreException
				b[0]=new Hotel();
				//b[0]=new Building();抛出同样的异常，只能是House或者其子类
			}catch(Exception e){
				System.out.println(e);
				//output: java.lang.ArrayStoreException: Hotel
			}
		}
	}
编译通过，运行抛出异常。上面的b数组实际上运行时类型是House[]的，它处理的是House[]，因此向数组中放置异构类型（或者父类型）就会抛出异常。
	
我觉得使用通配符好蛋疼，如：“<? extends Number>”，表示任何事物的概念太乱。如下：

	import java.util.*;
	public class Demo{
		public static void main(String[] args){
			//! List<Number> list=new ArrayList<Integer>();编译不通过持有类型不一样
			List<? extends Number> list=new ArrayList<Integer>();
			//它并不知道确切的类型(它是任何事物)，我们不能添加任何具体类型到list，除了null
			//!  list.add(new Integer(2));  //错误的
		}
	}
相比之下，超类型通配符（<? super T>）就显得非常好用，如下展示了使用了"<? super T>"的好处：
	
	import java.util.*;
	class Building{}
	class House extends Building{}
	class Hotel extends Building{}
	public class Demo{
		static List<House> house=new ArrayList<House>();
		static List<Building> building=new ArrayList<Building>();
		static <T> void write(List<T>list,T item){
			list.add(item);
		}
		static void f1(){
			write(house,new House());
			//! write(building,new House());  error
			building.add(new House());//can add
		}	
		static <T> void writeWithSuper(List<? super T>list,T item){
			list.add(item);
		}
		static void f2(){
			writeWithSuper(house,new House());
			writeWithSuper(building,new House());//can add
		}
    	public static void main(String[] args){
			f1();f2();
	    }
	}
